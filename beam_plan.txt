# Logic
We have 8 U3 gates. Leader uses ~80 T-gates per U3.
Target: T <= 75, Dist <= 0.01.

# Algorithm: Beam Search
1. Start with Identity.
2. Expand by `{H, S, T}` gates.
3. Keep top `beam_width` (e.g., 2000) states sorted by `dist(Current, Target)`.
4. Pruning:
   - If T > 75, drop.
   - If Dist doesn't improve after K steps, maybe drop? (No, sequences can move away then closer).
5. Stop when Dist < 0.01.

# Cost Function
$f(n) = \text{dist}(U_{current}, U_{target})$
We minimize this.
Strictly this is Greedy Best-First Search with Beam.

# Complexity
Branching factor 5 (H, S, Sdg, T, Tdg). 
Depth 75 is too deep for BFS.
Beam Search restricts width.
Width 5000 is feasible in Python with NumPy.

# Vectorization
We can vectorize the beam expansion.
Current states: (Width, 2, 2).
Multiply by 5 gates -> (5*Width, 2, 2).
Compute Dists.
Argsort, take top Width.
Repeat.
